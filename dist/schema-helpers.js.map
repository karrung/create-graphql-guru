{"version":3,"sources":["../src/schema-helpers.js"],"names":["args","resolver","schema","moduleRoot","process","cwd","option","parse","argv","program","module","Error","moduleName","split","toLowerCase","fileName","methods","length","database","path","moduleMethods","map","method","importDatabase","join"],"mappings":";;;;;QAegBA,I,GAAAA,I;QAeAC,Q,GAAAA,Q;QAuBAC,M,GAAAA,M;;AArDhB;;;;AACA;;;;AACA,IAAMC,aAAgBC,QAAQC,GAAR,EAAhB,oBAAN;;kBAEe,oBACZC,MADY,CAEX,mBAFW,EAGX,yDAHW,EAKZA,MALY,CAKL,uBALK,EAKoB,eALpB,EAMZA,MANY,CAML,2BANK,EAMwB,qCANxB,EAOZA,MAPY,CAOL,8BAPK,EAO2B,yBAP3B,EAQZA,MARY,CAQL,2BARK,EAQwB,sBARxB,EASZC,KATY,CASNH,QAAQI,IATF,C;AAWR,SAASR,IAAT,OAA4B;AAAA,MAAXS,OAAW,QAAXA,OAAW;;AACjC,MAAIA,QAAQC,MAAR,IAAkB,OAAOD,QAAQC,MAAf,KAA0B,QAAhD,EAA0D;AACxD,UAAM,IAAIC,KAAJ,CAAU,yBAAV,CAAN;AACD;AACD,MAAMC,aAAaH,QAAQC,MAAR,CAAeG,KAAf,CAAqB,GAArB,CAAnB;;AAEA,SAAO;AACLD,gBAAYA,WAAW,CAAX,EAAcE,WAAd,EADP;AAELC,cAAUH,WAAW,CAAX,IAAgBA,WAAW,CAAX,EAAcE,WAAd,EAAhB,GAA8C,EAFnD;AAGLE,aAASP,QAAQT,IAAR,CAAaiB,MAAb,KAAwB,CAAxB,GAA4BR,QAAQT,IAApC,GAA2C,IAH/C;AAILkB,cAAUT,QAAQS,QAAR,KAAqB,QAArB,GAAgCT,QAAQS,QAAxC,GAAmD,IAJxD;AAKLC,UAAMV,QAAQU,IAAR,GAAkBhB,UAAlB,SAAgCM,QAAQU,IAAxC,GAAiDhB;AALlD,GAAP;AAOD;;AAEM,SAASF,QAAT,QAAsD;AAAA,MAAjCiB,QAAiC,SAAjCA,QAAiC;AAAA,MAAvBF,OAAuB,SAAvBA,OAAuB;AAAA,MAAdJ,UAAc,SAAdA,UAAc;;AAC3D,MAAMQ,gBAAgBJ,WAAW,IAAX,GAClB,EADkB,GAElBA,QAAQK,GAAR,CACE;AAAA,qBAEJC,MAFI;AAAA,GADF,CAFJ;;AAUA,MAAMC,iBAAiBL,uBACTA,QADS,qBACcA,QADd,mBAInB,EAJJ;;AAMA,SAAUK,cAAV,6BAAgD,uBAAWX,UAAX,CAAhD,UAA0EM,WAAW,aAAaA,QAAb,GAAwB,GAAnC,GAAyC,EAAnH,YACAE,cAAcI,IAAd,CAAmB,IAAnB,CADA;AAID;;AAEM,SAAStB,MAAT,QAA0C;AAAA,MAAvBc,OAAuB,SAAvBA,OAAuB;AAAA,MAAdJ,UAAc,SAAdA,UAAc;;AAC/C,SAAOI,QACJK,GADI,CAEH;AAAA,mCAEJT,UAFI,GAES,uBAAWU,MAAX,CAFT,YAEkC,uBAAWV,UAAX,CAFlC;AAAA,GAFG,EAQJY,IARI,CAQC,EARD,CAAP;AASD","file":"schema-helpers.js","sourcesContent":["import program from 'commander';\nimport { capitalize } from './utils';\nconst moduleRoot = `${process.cwd()}/server/modules`;\n\nexport default program\n  .option(\n    '-p, --path [path]',\n    'Path to where module will be created, relative to root.'\n  )\n  .option('-m, --module [module]', 'Modules name.')\n  .option('-d, --database [database]', 'Extends module with database client')\n  .option('-r, --resolver [resolver...]', 'Create mutation resolve')\n  .option('-s, --schema [schema....]', 'Name of query module')\n  .parse(process.argv);\n\nexport function args ({ program }) {\n  if (program.module || typeof program.module !== 'string') {\n    throw new Error('No module name provide.');\n  }\n  const moduleName = program.module.split('.');\n\n  return {\n    moduleName: moduleName[0].toLowerCase(),\n    fileName: moduleName[1] ? moduleName[1].toLowerCase() : '',\n    methods: program.args.length !== 0 ? program.args : null,\n    database: program.database !== 'string' ? program.database : null,\n    path: program.path ? `${moduleRoot}/${program.path}` : moduleRoot\n  };\n}\n\nexport function resolver ({ database, methods, moduleName }) {\n  const moduleMethods = methods == null\n    ? []\n    : methods.map(\n        method =>\n          ` \n  ${method} ({ args, context, databases, locals, models, req }) {\n\n  }`\n      );\n\n  const importDatabase = database\n    ? `import ${database} from 'guru-${database};'\n    \n`\n    : '';\n\n  return `${importDatabase}export default class ${capitalize(moduleName)} ${database ? 'extends ' + database + ' ' : ''}{\n${moduleMethods.join('\\n')}\n};\n`;\n}\n\nexport function schema ({ methods, moduleName }) {\n  return methods\n    .map(\n      method =>\n        `# Add description\n${moduleName}${capitalize(method)}(): ${capitalize(moduleName)}\n\n`\n    )\n    .join('');\n}\n"]}